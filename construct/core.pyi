from construct.lib import (
    Container,
    ListContainer,
    RebufferedBytesIO,
    HexDisplayedBytes,
    HexDisplayedDict,
    HexDisplayedInteger,
    HexDumpDisplayedBytes,
    HexDumpDisplayedDict,
)
from construct.expr import Path

import enum
import arrow
import io

# from construct.version import *
from typing import (
    Any,
    Optional as TypingOptional,
    Callable,
    IO,
    Mapping as TypingMapping,
    List,
    Dict,
    Union as TypingUnion,
    Hashable,
    TypeVar,
    Sequence as TypingSequence,
    Container as TypingContainer,
    Iterable,
    MutableMapping,
    NamedTuple as TypingNamedTuple,
    Generic,
    get_type_hints
)

# Additional types to make some of what follows easier

# A parametrizable union which represents "either a _T or a context lambda returning a _T"
# e.g. ContextVariable[int] is either an integer or a callable accepting a single Container
# argument which returns an integer.
_T = TypeVar("_T")
ContextLambda = Callable[[Container], _T]
ContextVariable = TypingUnion[_T, ContextLambda[_T]]

_EncodingType = enum.Enum(
    "_StringEncoding",
    {
        "ascii": "ascii",
        "utf8": "utf8",
        "utf_8": "utf_8",
        "u8": "u8",
        "utf8_": "utf-8",
        "utf16": "utf16",
        "utf_16": "utf_16",
        "utf16_": "utf-16",
        "u16": "u16",
        "utf_16_be": "utf_16_be",
        "utf_16_be_": "utf-16-be",
        "utf_16_le": "utf_16_le",
        "utf_16_le_": "utf-16-le",
        "utf32": "utf32",
        "utf_32": "utf_32",
        "utf32_": "utf-32",
        "u32": "u32",
        "utf_32_be": "utf_32_be",
        "utf_32_be_": "utf-32-be",
        "utf_32_le": "utf_32_le",
        "utf_32_le_": "utf-32-le",
    },
)

ListPredicate = Callable[[Any, ListContainer, Container], bool]
ParsedCallable = TypingOptional[Callable[[Any, Container], None]]

class ConstructError(Exception): ...
class SizeofError(ConstructError): ...
class AdaptationError(ConstructError): ...
class ValidationError(ConstructError): ...
class StreamError(ConstructError): ...
class FormatFieldError(ConstructError): ...
class IntegerError(ConstructError): ...
class StringError(ConstructError): ...
class MappingError(ConstructError): ...
class RangeError(ConstructError): ...
class RepeatError(ConstructError): ...
class ConstError(ConstructError): ...
class IndexFieldError(ConstructError): ...
class CheckError(ConstructError): ...
class ExplicitError(ConstructError): ...
class NamedTupleError(ConstructError): ...
class TimestampError(ConstructError): ...
class UnionError(ConstructError): ...
class SelectError(ConstructError): ...
class SwitchError(ConstructError): ...
class StopFieldError(ConstructError): ...
class PaddingError(ConstructError): ...
class TerminatedError(ConstructError): ...
class RawCopyError(ConstructError): ...
class RotationError(ConstructError): ...
class ChecksumError(ConstructError): ...
class CancelParsing(ConstructError): ...

def singleton(arg: _T) -> _T: ...
def stream_read(stream: IO, length: int) -> bytes: ...
def stream_read_entire(stream: IO) -> bytes: ...
def stream_write(
    stream: IO, data: bytes, length: TypingOptional[Any] = ...
) -> None: ...
def stream_seek(stream: IO, offset: int, whence: int = ...) -> int: ...
def stream_tell(stream: IO) -> int: ...
def stream_size(stream: IO) -> int: ...
def stream_iseof(stream: IO) -> bool: ...

class CodeGen:
    blocks: List[Any] = ...
    nextid: int = ...
    parsercache: Dict[Any, Any] = ...
    linkedinstances: Dict[Any, Any] = ...
    linkedparsers: Dict[Any, Any] = ...
    def __init__(self) -> None: ...
    def allocateId(self): ...
    def append(self, block: Any) -> None: ...
    def toString(self): ...

class KsyGen:
    instances: Any = ...
    enums: Any = ...
    types: Any = ...
    nextid: int = ...
    def __init__(self) -> None: ...
    def allocateId(self): ...

def hyphenatedict(d: TypingMapping[str, str]) -> Dict[str, str]: ...
def hyphenatelist(l: Iterable[TypingMapping[str, str]]) -> List[Dict[str, str]]: ...
def mergefields(*subcons: Iterable["Construct"]) -> List["Construct"]: ...
def extractfield(sc: "Construct") -> "Construct": ...
def evaluate(param: ContextVariable[_T], context: Container) -> _T: ...
def disableif(condition: bool) -> str: ...

class Construct:
    name: str = ...
    docs: str = ...
    flagbuildnone: bool = ...
    flagembedded: bool = ...
    parsed: ParsedCallable = ...
    def __init__(self) -> None: ...
    def __repr__(self) -> str: ...
    def __getstate__(self): ...
    def __setstate__(self, attrs: Any) -> None: ...
    def __copy__(self): ...
    def parse(self, data: bytes, **contextkw: TypingMapping[str, Any]): ...
    def parse_stream(self, stream: IO, **contextkw: TypingMapping[str, Any]): ...
    def parse_file(self, filename: str, **contextkw: TypingMapping[str, Any]): ...
    def _parsereport(self, stream: IO, context: Container, path: Path): ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def build(self, obj: Any, **contextkw: TypingMapping[str, Any]) -> bytes: ...
    def build_stream(
        self, obj: Any, stream: IO, **contextkw: TypingMapping[str, Any]
    ) -> None: ...
    def build_file(
        self, obj: Any, filename: Any, **contextkw: TypingMapping[str, Any]
    ) -> None: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def sizeof(self, **contextkw: TypingMapping[str, Any]): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _actualsize(self, stream: IO, context: Container, path: Path) -> int: ...
    def compile(self, filename: TypingOptional[str] = ...) -> "Compiled": ...
    def _compileinstance(self, code: CodeGen) -> str: ...
    def _compileparse(self, code: CodeGen) -> str: ...
    def _compilebuild(self, code: CodeGen) -> str: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitbuild(self, code: CodeGen) -> str: ...
    def benchmark(
        self, sampledata: bytes, filename: TypingOptional[str] = ...
    ) -> str: ...
    def export_ksy(
        self, schemaname: str = ..., filename: TypingOptional[str] = ...
    ) -> str: ...
    def _compileseq(
        self, ksy: KsyGen, bitwise: bool = ..., recursion: int = ...
    ) -> List[Dict[str, str]]: ...
    def _compileprimitivetype(
        self, ksy: KsyGen, bitwise: bool = ..., recursion: int = ...
    ) -> str: ...
    def _compilefulltype(
        self, ksy: KsyGen, bitwise: bool = ..., recursion: int = ...
    ) -> Dict[str, str]: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...
    def __rtruediv__(self, name: str) -> "Renamed": ...
    def __rdiv__(self, name: str) -> "Renamed": ...
    def __mul__(self, other: TypingUnion[str, bytes, Callable]) -> "Renamed": ...
    def __rmul__(self, other: TypingUnion[str, bytes, Callable]) -> "Renamed": ...
    def __add__(self, other: Any) -> "Struct": ...
    def __rshift__(self, other: Any) -> "Struct": ...
    def __getitem__(self, count: ContextVariable[int]) -> "Array": ...

class Subconstruct(Construct):
    subcon: Construct = ...
    flagbuildnone: bool = ...
    flagembedded: bool = ...
    def __init__(self, subcon: Construct) -> None: ...
    def __repr__(self) -> str: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...

class Adapter(Subconstruct):
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _decode(self, obj: Any, context: Container, path: Path): ...
    def _encode(self, obj: Any, context: Container, path: Path): ...

class SymmetricAdapter(Adapter):
    def _encode(self, obj: Any, context: Container, path: Path): ...

class Validator(SymmetricAdapter):
    def _decode(self, obj: _T, context: Container, path: Path) -> _T: ...
    def _validate(self, obj: Any, context: Container, path: Path) -> bool: ...

class Tunnel(Subconstruct):
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _decode(self, data: bytes, context: Container, path: Path): ...
    def _encode(self, data: Any, context: Container, path: Path) -> bytes: ...

class Compiled(Construct):
    source: Any = ...
    defersubcon: Construct = ...
    parsefunc: Any = ...
    def __init__(self, source: Any, defersubcon: Construct, parsefunc: Any) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def compile(self, filename: TypingOptional[str] = ...) -> "Compiled": ...
    def benchmark(
        self, sampledata: bytes, filename: TypingOptional[str] = ...
    ) -> str: ...

class Bytes(Construct):
    length: int = ...
    def __init__(self, length: ContextVariable[int]) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> bytes: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path) -> bytes: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class GreedyBytes(Construct):
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

def Bitwise(subcon: Construct) -> Subconstruct: ...
def Bytewise(subcon: Construct) -> Subconstruct: ...

class FormatField(Construct):
    fmtstr: str = ...
    length: int = ...
    packer: "Struct" = ...
    def __init__(self, endianity: str, format: str) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...
    def __rtruediv__(self, name: str) -> "Renamed": ...

class BytesInteger(Construct):
    length: ContextVariable[int] = ...
    signed: bool = ...
    swapped: bool = ...
    def __init__(
        self, length: ContextVariable[int], signed: bool = ..., swapped: bool = ...
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> int: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...

class BitsInteger(Construct):
    length: ContextVariable[int] = ...
    signed: bool = ...
    swapped: bool = ...
    def __init__(
        self, length: ContextVariable[int], signed: bool = ..., swapped: bool = ...
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> int: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...

Bit = BitsInteger(1)
Nibble = BitsInteger(2)
Octet = BitsInteger(4)

Int8ub = FormatField(">", "B")
Int16ub = FormatField(">", "H")
Int32ub = FormatField(">", "L")
Int64ub = FormatField(">", "Q")

Int8sb = FormatField(">", "b")
Int16sb = FormatField(">", "h")
Int32sb = FormatField(">", "l")
Int64sb = FormatField(">", "q")

Int8ul = FormatField("<", "B")
Int16ul = FormatField("<", "H")
Int32ul = FormatField("<", "L")
Int64ul = FormatField("<", "Q")

Int8sl = FormatField("<", "b")
Int16sl = FormatField("<", "h")
Int32sl = FormatField("<", "l")
Int64sl = FormatField("<", "q")

Int8un = FormatField("=", "B")
Int16un = FormatField("=", "H")
Int32un = FormatField("=", "L")
Int64un = FormatField("=", "Q")

Int8sn = FormatField("=", "b")
Int16sn = FormatField("=", "h")
Int32sn = FormatField("=", "l")
Int64sn = FormatField("=", "q")

Byte = Int8ub
Short = Int16ub
Int = Int32ub
Long = Int64ub

Float32b = FormatField(">", "f")
Float32l = FormatField("<", "f")
Float32n = FormatField("=", "f")

Float64b = FormatField(">", "d")
Float64l = FormatField("<", "d")
Float64n = FormatField("=", "d")

Single = Float32b
Double = Float64b
native: bool = ...

Int24ub = BytesInteger(3, signed=False, swapped=False)
Int24ul = BytesInteger(3, signed=False, swapped=True)
Int24un = BytesInteger(3, signed=False, swapped=native)
Int24sb = BytesInteger(3, signed=True, swapped=False)
Int24sl = BytesInteger(3, signed=True, swapped=True)
Int24sn = BytesInteger(3, signed=True, swapped=native)

class VarInt(Construct):
    def _parse(self, stream: IO, context: Container, path: Path) -> int: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...

possiblestringencodings: Dict[_EncodingType, int]

def encodingunit(encoding: _EncodingType) -> bytes: ...

class StringEncoded(Adapter):
    encoding: _EncodingType = ...
    def __init__(self, subcon: Construct, encoding: _EncodingType) -> None: ...
    def _decode(self, obj: bytes, context: Container, path: Path) -> str: ...
    def _encode(self, obj: str, context: Container, path: Path) -> bytes: ...
    def _emitparse(self, code: CodeGen) -> str: ...

def PaddedString(
    length: ContextVariable[int], encoding: _EncodingType
) -> StringEncoded: ...
def PascalString(
    lengthfield: ContextVariable[int], encoding: _EncodingType
) -> StringEncoded: ...
def CString(encoding: _EncodingType) -> StringEncoded: ...
def GreedyString(encoding: _EncodingType) -> StringEncoded: ...

class Flag(Construct):
    def _parse(self, stream: IO, context: Container, path: Path) -> bool: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class EnumInteger(int): ...

class EnumIntegerString(str):
    def __repr__(self) -> str: ...
    def __int__(self) -> int: ...
    @staticmethod
    def new(intvalue: int, stringvalue: str): ...

class Enum(Adapter):
    encmapping: Dict[EnumIntegerString, int]
    decmapping: Dict[int, EnumIntegerString]
    ksymapping: Dict[int, str]
    def __init__(
        self,
        subcon: Construct,
        *merge: TypingOptional[Iterable[TypingUnion[enum.IntEnum, enum.IntFlag]]],
        **mapping: TypingOptional[MutableMapping[str, int]]
    ) -> None: ...
    def __getattr__(self, name: str): ...
    def _decode(
        self, obj: Any, context: Container, path: Path
    ) -> TypingUnion[EnumIntegerString, EnumInteger]: ...
    def _encode(
        self, obj: TypingUnion[int, EnumIntegerString], context: Container, path: Path
    ) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...

class BitwisableString(str):
    def __or__(self, other: Any) -> "BitwisableString": ...

class FlagsEnum(Adapter):
    flags: MutableMapping[str, int] = ...
    reverseflags: MutableMapping[int, str] = ...
    def __init__(
        self,
        subcon: Construct,
        *merge: TypingOptional[Iterable[TypingUnion[enum.IntEnum, enum.IntFlag]]],
        **flags: MutableMapping[str, int]
    ) -> None: ...
    def __getattr__(self, name: str) -> BitwisableString: ...
    def _decode(self, obj: int, context: Container, path: Path) -> Container: ...
    def _encode(
        self, obj: TypingUnion[int, str, dict], context: Container, path: Path
    ) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...

class Mapping(Adapter):
    decmapping: MutableMapping[Hashable, Hashable] = ...
    encmapping: MutableMapping[Hashable, Hashable] = ...
    def __init__(
        self, subcon: Construct, mapping: MutableMapping[Hashable, Hashable]
    ) -> None: ...
    def _decode(self, obj: Hashable, context: Container, path: Path): ...
    def _encode(self, obj: Hashable, context: Container, path: Path): ...
    def _emitparse(self, code: CodeGen) -> str: ...

class Struct(Construct):
    subcons: List[Construct] = ...
    _subcons: Container = ...
    flagbuildnone: bool = ...
    def __init__(
        self, *subcons: Iterable[Construct], **subconskw: TypingMapping[str, Construct]
    ) -> None: ...
    def __getattr__(self, name: str) -> Construct: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> Container: ...
    def _build(
        self, obj: TypingOptional[Container], stream: IO, context: Container, path: Path
    ) -> Container: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...

class Sequence(Construct):
    subcons: List[Construct] = ...
    _subcons: Container = ...
    flagbuildnone: bool = ...
    def __init__(
        self, *subcons: Iterable[Construct], **subconskw: TypingMapping[str, Construct]
    ) -> None: ...
    def __getattr__(self, name: str) -> Construct: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> ListContainer: ...
    def _build(
        self, obj: Iterable, stream: IO, context: Container, path: Path
    ) -> ListContainer: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...

class Array(Subconstruct):
    count: ContextVariable[int] = ...
    discard: bool = ...
    def __init__(
        self, count: ContextVariable[int], subcon: Construct, discard: bool = ...
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> ListContainer: ...
    def _build(
        self, obj: TypingSequence, stream: IO, context: Container, path: Path
    ) -> ListContainer: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class GreedyRange(Subconstruct):
    discard: bool = ...
    def __init__(self, subcon: Construct, discard: bool = ...) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> ListContainer: ...
    def _build(
        self, obj: Iterable, stream: IO, context: Container, path: Path
    ) -> ListContainer: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class RepeatUntil(Subconstruct):
    predicate: ListPredicate = ...
    discard: bool = ...
    def __init__(
        self, predicate: ListPredicate, subcon: Construct, discard: bool = ...
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> ListContainer: ...
    def _build(
        self, obj: Iterable, stream: IO, context: Container, path: Path
    ) -> ListContainer: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class Embedded(Subconstruct):
    flagembedded: bool = ...
    def __init__(self, subcon: Construct) -> None: ...

class Renamed(Subconstruct):
    name: str = ...
    docs: str = ...
    parsed: ParsedCallable = ...
    def __init__(
        self,
        subcon: Construct,
        newname: TypingOptional[str] = ...,
        newdocs: TypingOptional[str] = ...,
        newparsed: ParsedCallable = ...,
    ) -> None: ...
    def __getattr__(self, name: Any): ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class Const(Subconstruct):
    value: bytes = ...
    flagbuildnone: bool = ...
    def __init__(
        self, value: bytes, subcon: TypingOptional[Construct] = ...
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> bytes: ...
    def _build(
        self, obj: TypingOptional[bytes], stream: IO, context: Container, path: Path
    ): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class Computed(Construct):
    func: ContextLambda[Any] = ...
    flagbuildnone: bool = ...
    def __init__(self, func: ContextLambda[Any]) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

class Index(Construct):
    flagbuildnone: bool = ...
    def __init__(self) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...

class Rebuild(Subconstruct):
    func: Any = ...
    flagbuildnone: bool = ...
    def __init__(self, subcon: Construct, func: Any) -> None: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class Default(Subconstruct):
    value: Any = ...
    flagbuildnone: bool = ...
    def __init__(self, subcon: Construct, value: Any) -> None: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class Check(Construct):
    func: ContextVariable[bool] = ...
    flagbuildnone: bool = ...
    def __init__(self, func: ContextVariable[bool]) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> None: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path) -> None: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

class Error(Construct):
    flagbuildnone: bool = ...
    def __init__(self) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

class FocusedSeq(Construct):
    parsebuildfrom: ContextVariable[str] = ...
    subcons: List[Construct] = ...
    _subcons: Container = ...
    def __init__(
        self,
        parsebuildfrom: ContextVariable[str],
        *subcons: List[Construct],
        **subconskw: TypingMapping[str, Construct]
    ) -> None: ...
    def __getattr__(self, name: str) -> Construct: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...

class Pickled(Construct):
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: _T, stream: IO, context: Container, path: Path) -> _T: ...

class Numpy(Construct):
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: _T, stream: IO, context: Container, path: Path) -> _T: ...

class NamedTuple(Adapter):
    tuplename: str = ...
    tuplefields: TypingUnion[str, List[str]] = ...
    factory: TypingNamedTuple = ...
    def __init__(
        self,
        tuplename: str,
        tuplefields: TypingUnion[str, List[str]],
        subcon: TypingUnion[Struct, Sequence, Array, GreedyRange],
    ) -> None: ...
    def _decode(
        self,
        obj: TypingUnion[Struct, Sequence, Array, GreedyRange],
        context: Container,
        path: Path,
    ) -> TypingNamedTuple: ...
    def _encode(
        self, obj: Any, context: Container, path: Path
    ) -> TypingUnion[Container, List]: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

def Timestamp(
    subcon: Construct,
    unit: TypingUnion[int, float, str],
    epoch: TypingUnion[int, arrow.Arrow, str],
) -> Adapter: ...

class Hex(Adapter):
    def _decode(
        self, obj: TypingUnion[int, str, bytes, dict], context: Container, path: Path
    ) -> TypingUnion[HexDisplayedInteger, HexDisplayedBytes, HexDisplayedDict]: ...
    def _encode(self, obj: _T, context: Container, path: Path) -> _T: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class HexDump(Adapter):
    def _decode(
        self, obj: TypingUnion[str, bytes, dict], context: Container, path: Path
    ) -> TypingUnion[HexDumpDisplayedBytes, HexDisplayedDict]: ...
    def _encode(self, obj: _T, context: Container, path: Path) -> _T: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class Union(Construct):
    parsefrom: TypingUnion[None, int, str, ContextLambda] = ...
    subcons: List[Construct] = ...
    _subcons: Dict[str, Construct] = ...
    def __init__(
        self,
        parsefrom: TypingUnion[None, int, str, ContextLambda],
        *subcons: List[Construct],
        **subconskw: TypingMapping[str, Construct]
    ) -> None: ...
    def __getattr__(self, name: str) -> Construct: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> Container: ...
    def _build(
        self, obj: Any, stream: IO, context: Container, path: Path
    ) -> Container: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

class Select(Construct):
    subcons: List[Construct] = ...
    flagbuildnone: bool = ...
    flagembedded: bool = ...
    def __init__(
        self, *subcons: List[Construct], **subconskw: TypingMapping[str, Construct]
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...

def Optional(subcon: Construct) -> Select: ...
def If(condfunc: ContextVariable[bool], subcon: Construct) -> "IfThenElse": ...

class IfThenElse(Construct):
    condfunc: ContextVariable[bool] = ...
    thensubcon: Construct = ...
    elsesubcon: Construct = ...
    flagbuildnone: bool = ...
    def __init__(
        self,
        condfunc: ContextVariable[bool],
        thensubcon: Construct,
        elsesubcon: Construct,
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...

class Switch(Construct):
    keyfunc: ContextVariable[Any] = ...
    cases: TypingMapping[Hashable, Construct] = ...
    default: Construct = ...
    flagbuildnone: bool = ...
    def __init__(
        self,
        keyfunc: ContextVariable[Any],
        cases: TypingMapping[Hashable, Construct],
        default: TypingOptional[Construct] = ...,
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

def EmbeddedSwitch(
    merged: Struct, selector: Any, mapping: TypingMapping[Hashable, Struct]
) -> Struct: ...

class StopIf(Construct):
    condfunc: ContextVariable[bool] = ...
    flagbuildnone: bool = ...
    def __init__(self, condfunc: ContextVariable[bool]) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

def Padding(length: ContextVariable[int], pattern: bytes = ...) -> "Padded": ...

class Padded(Subconstruct):
    length: ContextVariable[int] = ...
    pattern: bytes = ...
    def __init__(
        self, length: ContextVariable[int], subcon: Construct, pattern: bytes = ...
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class Aligned(Subconstruct):
    modulus: ContextVariable[int] = ...
    pattern: TypingOptional[bytes] = ...
    def __init__(
        self,
        modulus: ContextVariable[int],
        subcon: Construct,
        pattern: TypingOptional[bytes] = ...,
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

def AlignedStruct(
    modulus: ContextVariable[int],
    *subcons: List[Construct],
    **subconskw: TypingMapping[str, Construct]
) -> Struct: ...
def BitStruct(
    *subcons: List[Construct], **subconskw: TypingMapping[str, Construct]
) -> Subconstruct: ...

class Pointer(Subconstruct):
    offset: ContextVariable[int] = ...
    stream: TypingOptional[ContextLambda[IO]] = ...
    def __init__(
        self,
        offset: ContextVariable[int],
        subcon: Construct,
        stream: TypingOptional[ContextLambda[IO]] = ...,
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> str: ...

class Peek(Subconstruct):
    flagbuildnone: bool = ...
    def __init__(self, subcon: Construct) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

class Seek(Construct):
    at: ContextVariable[int] = ...
    whence: TypingOptional[ContextVariable[int]] = ...
    flagbuildnone: bool = ...
    def __init__(
        self,
        at: ContextVariable[int],
        whence: TypingOptional[ContextVariable[int]] = ...,
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> int: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path) -> int: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

class Tell(Construct):
    flagbuildnone: bool = ...
    def __init__(self) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> int: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path) -> int: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

class Pass(Construct):
    flagbuildnone: bool = ...
    def __init__(self) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> None: ...
    def _build(self, obj: _T, stream: IO, context: Container, path: Path) -> _T: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class Terminated(Construct):
    flagbuildnone: bool = ...
    def __init__(self) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...

class RawCopy(Subconstruct):
    def _parse(self, stream: IO, context: Container, path: Path) -> Container: ...
    def _build(
        self, obj: Any, stream: IO, context: Container, path: Path
    ) -> Container: ...

def ByteSwapped(subcon: Construct) -> "Transformed": ...
def BitsSwapped(subcon: Construct) -> TypingUnion["Transformed", "Restreamed"]: ...

class Prefixed(Subconstruct):
    lengthfield: Construct = ...
    includelength: bool = ...
    def __init__(
        self, lengthfield: Construct, subcon: Construct, includelength: bool = ...
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _actualsize(self, stream: IO, context: Container, path: Path): ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> List[Dict[str, str]]: ...

def PrefixedArray(countfield: Construct, subcon: Construct) -> FocusedSeq: ...

class FixedSized(Subconstruct):
    length: ContextVariable[int] = ...
    def __init__(self, length: ContextVariable[int], subcon: Construct) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class NullTerminated(Subconstruct):
    term: bytes = ...
    include: bool = ...
    consume: bool = ...
    require: bool = ...
    def __init__(
        self,
        subcon: Construct,
        term: bytes = ...,
        include: bool = ...,
        consume: bool = ...,
        require: bool = ...,
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class NullStripped(Subconstruct):
    pad: bytes = ...
    def __init__(self, subcon: Construct, pad: bytes = ...) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Dict[str, Any]: ...

class RestreamData(Subconstruct):
    datafunc: TypingUnion[bytes, io.BytesIO, Construct, ContextLambda[bytes]] = ...
    flagbuildnone: bool = ...
    def __init__(
        self,
        datafunc: TypingUnion[bytes, io.BytesIO, Construct, ContextLambda[bytes]],
        subcon: Construct,
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...
    def _emitparse(self, code: CodeGen) -> str: ...

class Transformed(Subconstruct):
    decodefunc: Callable[[bytes], bytes] = ...
    decodeamount: int = ...
    encodefunc: Callable[[bytes], bytes] = ...
    encodeamount: int = ...
    def __init__(
        self,
        subcon: Construct,
        decodefunc: Callable[[bytes], bytes],
        decodeamount: int,
        encodefunc: Callable[[bytes], bytes],
        encodeamount: int,
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...

class Restreamed(Subconstruct):
    decoder: Callable[[bytes], bytes] = ...
    decoderunit: int = ...
    encoder: Callable[[bytes], bytes] = ...
    encoderunit: int = ...
    sizecomputer: Callable[[int], int] = ...
    def __init__(
        self,
        subcon: Construct,
        decoder: Callable[[bytes], bytes],
        decoderunit: int,
        encoder: Callable[[bytes], bytes],
        encoderunit: int,
        sizecomputer: Callable[[int], int],
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...

class ProcessXor(Subconstruct):
    padfunc: TypingUnion[int, bytes, ContextLambda[bytes]] = ...
    def __init__(
        self, padfunc: TypingUnion[int, bytes, ContextLambda[bytes]], subcon: Construct
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...

class ProcessRotateLeft(Subconstruct):
    precomputed_single_rotations: Dict[int, List[int]] = ...
    amount: ContextVariable[int] = ...
    group: ContextVariable[int] = ...
    def __init__(
        self,
        amount: ContextVariable[int],
        group: ContextVariable[int],
        subcon: Construct,
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...

class Checksum(Construct):
    checksumfield: Construct = ...
    hashfunc: Callable[[bytes], Any] = ...
    bytesfunc: ContextLambda[Any] = ...
    flagbuildnone: bool = ...
    def __init__(
        self,
        checksumfield: Construct,
        hashfunc: Callable[[bytes], Any],
        bytesfunc: ContextLambda[Any],
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...
    def _sizeof(self, context: Container, path: Path) -> int: ...

class Compressed(Tunnel):
    encoding: str = ...
    level: TypingOptional[int] = ...
    lib: Any = ...
    def __init__(
        self, subcon: Construct, encoding: str, level: TypingOptional[int] = ...
    ) -> None: ...
    def _decode(self, data: bytes, context: Container, path: Path): ...
    def _encode(self, data: Any, context: Container, path: Path) -> bytes: ...

class Rebuffered(Subconstruct):
    stream2: RebufferedBytesIO = ...
    def __init__(
        self, subcon: Construct, tailcutoff: TypingOptional[int] = ...
    ) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...

class Lazy(Subconstruct):
    def __init__(self, subcon: Construct) -> None: ...
    def _parse(
        self, stream: IO, context: Container, path: Path
    ) -> Callable[[], Any]: ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...

class LazyContainer(dict):
    _struct: Any = ...
    _stream: IO = ...
    _offsets: Any = ...
    _values: Any = ...
    _context: Container = ...
    _path: Path = ...
    def __init__(
        self,
        struct: Any,
        stream: IO,
        offsets: Any,
        values: Any,
        context: Container,
        path: Path,
    ) -> None: ...
    def __getattr__(self, name: Any): ...
    def __getitem__(self, index: Any): ...
    def __len__(self): ...
    def keys(self): ...
    def values(self): ...
    def items(self): ...
    __iter__: Any = ...
    def __eq__(self, other: Any) -> Any: ...
    def __repr__(self) -> str: ...

class LazyStruct(Construct):
    subcons: List[Construct] = ...
    _subcons: Container = ...
    _subconsindexes: Container = ...
    flagbuildnone: bool = ...
    def __init__(
        self, *subcons: List[Construct], **subconskw: TypingMapping[str, Construct]
    ) -> None: ...
    def __getattr__(self, name: str) -> Construct: ...
    def _parse(self, stream: IO, context: Container, path: Path) -> LazyContainer: ...
    def _build(
        self, obj: Any, stream: IO, context: Container, path: Path
    ) -> Container: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...

class LazyListContainer(list):
    _subcon: Construct = ...
    _stream: IO = ...
    _count: Any = ...
    _offsets: Any = ...
    _values: Any = ...
    _context: Container = ...
    _path: Path = ...
    def __init__(
        self,
        subcon: Construct,
        stream: IO,
        count: Any,
        offsets: Any,
        values: Any,
        context: Container,
        path: Path,
    ) -> None: ...
    def __getitem__(self, index: Any): ...
    def __getslice__(self, start: Any, stop: Any): ...
    def __len__(self): ...
    def __iter__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def __repr__(self) -> str: ...

class LazyArray(Subconstruct):
    count: ContextVariable[int] = ...
    def __init__(self, count: ContextVariable[int], subcon: Construct) -> None: ...
    def _parse(
        self, stream: IO, context: Container, path: Path
    ) -> LazyListContainer: ...
    def _build(
        self, obj: Any, stream: IO, context: Container, path: Path
    ) -> ListContainer: ...
    def _sizeof(self, context: Container, path: Path) -> int: ...

class LazyBound(Construct):
    subconfunc: Callable[[], Construct] = ...
    def __init__(self, subconfunc: Callable[[], Construct]) -> None: ...
    def _parse(self, stream: IO, context: Container, path: Path): ...
    def _build(self, obj: Any, stream: IO, context: Container, path: Path): ...

class ExprAdapter(Adapter):
    def __init__(
        self,
        subcon: Construct,
        decoder: Callable[[Any, Container], Any],
        encoder: Callable[[Any, Container], Any],
    ) -> None: ...

class ExprSymmetricAdapter(ExprAdapter):
    def __init__(
        self, subcon: Construct, encoder: Callable[[Any, Container], Any]
    ) -> None: ...

class ExprValidator(Validator):
    def __init__(
        self, subcon: Construct, validator: Callable[[Any, Container], bool]
    ) -> None: ...

def OneOf(subcon: Construct, valids: TypingContainer) -> ExprValidator: ...
def NoneOf(subcon: Construct, invalids: TypingContainer) -> ExprValidator: ...
def Filter(predicate: Callable[[Any, Container], bool], subcon: Construct): ...

class Slicing(Adapter):
    count: int = ...
    start: int = ...
    stop: int = ...
    step: int = ...
    empty: int = ...
    def __init__(
        self,
        subcon: Construct,
        count: int,
        start: int,
        stop: int,
        step: int = ...,
        empty: TypingOptional[Any] = ...,
    ) -> None: ...
    def _decode(self, obj: Any, context: Container, path: Path): ...
    def _encode(self, obj: Any, context: Container, path: Path): ...

class Indexing(Adapter):
    count: int = ...
    index: int = ...
    empty: Any = ...
    def __init__(
        self,
        subcon: Construct,
        count: int,
        index: int,
        empty: TypingOptional[Any] = ...,
    ) -> None: ...
    def _decode(self, obj: Any, context: Container, path: Path): ...
    def _encode(self, obj: Any, context: Container, path: Path): ...
